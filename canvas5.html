<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        .deScroll {
        }

        ::-webkit-scrollbar {
            width: 0px;
            height: 0px;
        }

        body {
            background-color: ivory;
        }


        .section{
            width: 100%;
            height: 100%;
            position: relative;
        }

        .aschLogo{
            position: absolute;
            width: 0;
            height: 0;
            top: 50%;
            left: 50%;
            z-index: 999;
            animation-name: aschLogoAnimate;
            animation-duration: 1.5s;
            animation-timing-function: linear;
            animation-delay: 3s;
            animation-fill-mode:forwards;
        }

        @keyframes aschLogoAnimate{
            0%{
                width: 0px;
                height: 0px;
                top:50% ;
                left:50% ;
            }

            60%{
                width: 400px;
                height: 400px;
                top:calc(50% - 180px);
                left:calc(50% - 200px);
            }

            100%{
                width: 200px;
                height: 200px;
                top:calc(50% - 80px);
                left:calc(50% - 100px);
            }
        }
        .aschLogo img{
            width: 100%;
            height: 100%;
        }

        canvas {
            background: #1d4277;
        }
    </style>
</head>
<body class="deScroll">
<div class="section">
    <canvas id="canvas" width=100% height=100%>抱歉，您的浏览器不支持canvas元素</canvas>
    <div class="aschLogo">
        <img src="images/aschHomeLogo.png" alt="asch-logo">
    </div>
</div>


<script>
  //  (function () {
  //    var lastTime = 0;
  //    var vendors = ['ms', 'moz', 'webkit', 'o'];
  //    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
  //      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  //      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  //    }
  //
  //    if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
  //      var currTime = new Date().getTime();
  //      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
  //      var id = window.setTimeout(function () {
  //          callback(currTime + timeToCall);
  //        },
  //        timeToCall);
  //      lastTime = currTime + timeToCall;
  //      return id;
  //    };
  //
  //    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
  //      clearTimeout(id);
  //    };
  //  }());

  //  vertices2.push({x: (cW / 10) * 9, y: 0});
  //  vertices2.push({x: (cW / 10) * 4, y: cH});


  var canvas = document.getElementById("canvas"), cW, cH;
  cW = canvas.width = window.innerWidth;
  cH = canvas.height = window.innerHeight;

  var ctx = canvas.getContext("2d");
  var t = 1;
  var canvasArr11 = [{x: cW / 10, y: 0}, {x: (cW / 10) * 6, y: cH}];
  var canvasArr12 = [{x: (cW / 10) * 9, y: 0}, {x: (cW / 10) * 4, y: cH}];
  var canvasArr21 = [{x: 0, y: (cH / 10) * (8.5)}, {x: (cW / 10) * 4, y: 0}];
  var canvasArr22 = [{x: cW, y: (cH / 10) * (8.5)}, {x: (cW / 10) * 6, y: 0}];
  var canvasArr31 = [{x: cW / 10, y: cH}, {x: cW / 2, y: (cH / 10) * (1.5)}];
  var canvasArr32 = [{x: (cW / 10) * 9, y: cH}, {x: cW / 2, y: (cH / 10) * (1.5)}];
  var canvasArr41 = [{x: (cW / 10) * (2.5), y: 0}, {x: (cW / 10) * 5, y: cH / 2}];
  var canvasArr51 = [{x: (cW / 10) * (2.5), y: 0}, {x: (cW / 10) * 5, y: cH / 2}];
  var canvasArr42 = [{x: (cW / 10) * (7.5), y: 0}, {x: (cW / 10) * 5, y: cH / 2}];
  var canvasArr52 = [{x: (cW / 10) * (7.5), y: 0}, {x: (cW / 10) * 5, y: cH / 2}];
  var clw1 = 1;
  var clw2 = 2;

  var cColor = "#98bae5";
  ctx.lineCap = "round";

  function canvasLine(t, cArr, clw, cColor) {
    ctx.lineWidth = clw;
    ctx.strokeStyle = cColor;
    var points = calcWaypoints(cArr);
    animate(points);

    function calcWaypoints(cArr) {
      var waypoints = [];
      for (var i = 1; i < cArr.length; i++) {
        var pt0 = cArr[i - 1];
        var pt1 = cArr[i];
        var dx = pt1.x - pt0.x;
        var dy = pt1.y - pt0.y;
        for (var j = 0; j <= 100; j++) {
          var x = pt0.x + dx * j / 100;
          var y = pt0.y + dy * j / 100;
          waypoints.push({
            x: x,
            y: y
          });
        }
      }
      return (waypoints);
    }

    function animate() {
      if (t < points.length - 1) {
        requestAnimationFrame(animate);
      }
      // draw a line segment from the last waypoint
      // to the current waypoint
      ctx.beginPath();
      ctx.moveTo(points[t - 1].x, points[t - 1].y);
      ctx.lineTo(points[t].x, points[t].y);
      ctx.closePath();
      ctx.stroke();
      // increment "t" to get the next waypoint
      t++;
    }
  }

  setTimeout(function () {
    canvasLine(t, canvasArr11, clw1, cColor);
    canvasLine(t, canvasArr12, clw1, cColor);
  },0);

  setTimeout(function () {
    canvasLine(t, canvasArr21, clw1, cColor);
    canvasLine(t, canvasArr22, clw1, cColor);
  },400);


  setTimeout(function () {
    canvasLine(t, canvasArr31, clw1, cColor);
    canvasLine(t, canvasArr32, clw1, cColor);
  }, 800);

  setTimeout(function () {
    canvasLine(t, canvasArr41, clw1, cColor);
    canvasLine(t, canvasArr42, clw1, cColor);
  }, 1200);

  setTimeout(function () {
    canvasLine(t, canvasArr51, clw2, cColor);
    canvasLine(t, canvasArr52, clw2, cColor);
  }, 2400);


  // variable to hold how many frames have elapsed in the animation
  //  var t = 1;
  //
  //  // define the path to plot
  //  var vertices1 = [], vertices2 = [];
  //  vertices1.push({
  //    x: cW / 10,
  //    y: 0
  //  });
  //  vertices1.push({
  //    x: (cW / 10) * 6,
  //    y: cH
  //  });
  //  vertices2.push({
  //    x: (cW / 10) * 9,
  //    y: 0
  //  });
  //  vertices2.push({
  //    x: (cW / 10) * 4,
  //    y: cH
  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * (2.5),
  //  //    y: 0
  //  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * 5,
  //  //    y: cH / 2
  //  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * (7.5),
  //  //    y: 0
  //  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * 5,
  //  //    y: cH / 2
  //  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * 4,
  //  //    y: 0
  //  //  });
  //  //  vertices.push({
  //  //    x: 0,
  //  //    y: (cH / 10) * 8
  //  //  });
  //  //  vertices.push({
  //  //    x: (cW / 10) * 6,
  //  //    y: 0
  //  //  });
  //  //  vertices.push({
  //  //    x: cW,
  //  //    y: (cH / 10) * 8
  //  //  });
  //  //  vertices.push({
  //  //    x: cW / 2,
  //  //    y: (cH / 10) * (1.5)
  //  //  });
  //
  //
  //  // draw the complete line
  //  //  ctx.lineWidth = 1;
  //  // tell canvas you are beginning a new path
  //  //  ctx.beginPath();
  //  // draw the path with moveTo and multiple lineTo's
  //  //  ctx.moveTo(0, 0);
  //  //  ctx.lineTo(300, 100);
  //  //  ctx.lineTo(80, 200);
  //  //  ctx.lineTo(10, 100);
  //  //  ctx.lineTo(0, 0);
  //  // stroke the path
  //  //  ctx.stroke();
  //
  //
  //  // set some style  1
  //  ctx.lineWidth = 1;
  //  ctx.strokeStyle = "#98bae5";
  //  // calculate incremental points along the path
  //  //  var points1 = calcWaypoints(vertices1);
  //  var points2 = calcWaypoints(vertices2);
  //  // extend the line from start to finish with animation
  //  //  animate(points1);
  //  animate(points2);
  //
  //
  //  // calc waypoints traveling along vertices
  //  function calcWaypoints(vertices1) {
  //    var waypoints = [];
  //    for (var i = 1; i < vertices1.length; i++) {
  //      var pt0 = vertices1[i - 1];
  //      var pt1 = vertices1[i];
  //      var dx = pt1.x - pt0.x;
  //      var dy = pt1.y - pt0.y;
  //      for (var j = 0; j <= 100; j++) {
  //        var x = pt0.x + dx * j / 100;
  //        var y = pt0.y + dy * j / 100;
  //        waypoints.push({
  //          x: x,
  //          y: y
  //        });
  //      }
  //    }
  //    return (waypoints);
  //  }
  //
  //
  //  function animate() {
  //    if (t < points2.length - 1) {
  //      requestAnimationFrame(animate);
  //    }
  ////    if (t < points2.length - 1) {
  ////      requestAnimationFrame(animate);
  ////    }
  //    // draw a line segment from the last waypoint
  //    // to the current waypoint
  //    ctx.beginPath();
  //    ctx.moveTo(points2[t - 1].x, points2[t - 1].y);
  //    ctx.lineTo(points2[t].x, points2[t].y);
  //    ctx.stroke();
  //    // increment "t" to get the next waypoint
  //    t++;
  //  }
  //

  //  2
  //  ctx.lineWidth = 1;
  //  ctx.strokeStyle = "blue";
  //  // calculate incremental points along the path
  ////  var points1 = calcWaypoints(vertices1);
  //  var points2 = calcWaypoints(vertices2);
  //  // extend the line from start to finish with animation
  ////  animate(points1);
  //  animate(points2);
  ////
  //
  //  // calc waypoints traveling along vertices
  //  function calcWaypoints(vertices2) {
  //    var waypoints = [];
  //    for (var i = 1; i < vertices2.length; i++) {
  //      var pt0 = vertices2[i - 1];
  //      var pt1 = vertices2[i];
  //      var dx = pt1.x - pt0.x;
  //      var dy = pt1.y - pt0.y;
  //      for (var j = 0; j < 100; j++) {
  //        var x = pt0.x + dx * j / 100;
  //        var y = pt0.y + dy * j / 100;
  //        waypoints.push({
  //          x: x,
  //          y: y
  //        });
  //      }
  //    }
  //    return (waypoints);
  //  }

  //
  //  function animate() {
  ////    if (t < points1.length - 1) {
  ////      requestAnimationFrame(animate);
  ////    }
  //    if (t < points2.length - 1) {
  //      requestAnimationFrame(animate);
  //    }
  //    // draw a line segment from the last waypoint
  //    // to the current waypoint
  //    ctx.beginPath();
  //    ctx.moveTo(points2[t - 1].x, points2[t - 1].y);
  //    ctx.lineTo(points2[t].x, points2[t].y);
  //    ctx.stroke();
  //    // increment "t" to get the next waypoint
  //    t++;
  //  }
</script>
</body>
</html>